# PokemonUltimate - Cursor AI Rules

> These rules are automatically loaded by Cursor for every conversation.

## ğŸš€ Automatic Context Loading

**ALWAYS read these files at the start of any task:**
1. `.ai/context.md` - Current project state, phase, completed systems
2. `docs/project_guidelines.md` - 24+ mandatory coding rules

**Read on-demand based on task:**
- New feature â†’ `docs/architecture/[relevant].md`
- Code quality â†’ `docs/anti-patterns.md`
- Examples needed â†’ `docs/examples/good_code.md`

## ğŸ“‹ Development Workflow

### When User Says "Implement X" or "Add X"
**MANDATORY WORKFLOW - Follow ALL steps in order:**

1. **Read Context & Specs**
   - Read `.ai/context.md` to understand current state
   - **CRITICAL: Read relevant architecture doc in `docs/architecture/`**
   - If spec is incomplete or missing details, **COMPLETE IT FIRST**
   - Identify ALL requirements from the spec
   - Note any elements to defer to later phases
   - Understand the expected API (method names, parameters)

2. **Verify Spec Completeness**
   - List what will be implemented vs deferred
   - Ensure spec has all necessary details (interfaces, classes, methods, examples)
   - If spec is incomplete, update it before implementation

3. **TDD: Write Functional Tests FIRST**
   - Create test file following naming: `[Feature]Tests.cs`
   - Write tests for ALL main scenarios from the spec
   - Use naming: `MethodName_Scenario_ExpectedResult`
   - Tests should compile but fail (red phase)

4. **Implement Feature**
   - Follow the spec exactly
   - Use existing patterns from codebase
   - Follow all coding rules (no magic strings, fail-fast, etc.)
   - Make tests pass (green phase)

5. **Write Edge Case Tests**
   - Create `[Feature]EdgeCasesTests.cs`
   - Test null inputs, boundary conditions, invalid states
   - Test real-world scenarios
   - If tests reveal missing functionality â†’ implement it

6. **Verify Implementation**
   - Run `dotnet build` - Verify no warnings
   - Run `dotnet test` - Verify all tests pass
   - **Validate against `docs/combat_use_cases.md`** (if combat-related)
   - Check `docs/checklists/feature_complete.md`

7. **Update Documentation**
   - Update `.ai/context.md` with new state
   - Update relevant architecture docs if API changed
   - Update status documents (e.g., `player_input_status.md`)
   - Update implementation plan if phase completed
   - Mention test count in response

### When User Says "Review X" or "Check X"
1. Read `docs/anti-patterns.md`
2. Verify against `docs/project_guidelines.md`
3. List issues found
4. Fix issues if requested

### When User Says "Edge Cases" or "Test X"
1. Read `docs/examples/good_tests.md` for patterns
2. Apply boundary testing (min/max values)
3. Test invalid inputs (null, negative, overflow)
4. Add real-world verification if applicable
5. If tests reveal missing functionality â†’ implement it

## âœ… Mandatory Rules (Always Apply)

### Code Quality
- **NO magic strings** â†’ Use `ErrorMessages.cs` or `GameMessages.cs`
- **NO magic numbers** â†’ Use named constants
- **NO try-catch** â†’ Unless absolutely necessary (I/O, external APIs)
- **Fail-fast** â†’ Throw exceptions for invalid inputs
- **Guard clauses** â†’ Validate at method start

### Architecture
- **Core/** â†’ Logic only, NO game data
- **Content/** â†’ Game data, catalogs, builders
- **Tests/** â†’ Mirror source structure
- **Blueprints** â†’ Immutable (no setters)
- **Instances** â†’ Mutable runtime state

### Testing
- **TDD** â†’ Tests before implementation
- **Naming** â†’ `MethodName_Scenario_ExpectedResult`
- **Two-phase** â†’ Functional tests, then edge cases
- **Real-world** â†’ Verify against official game data when applicable

### Documentation
- **XML docs** â†’ All public APIs
- **Update context** â†’ After major features

## ğŸ” Quick Reference

### Exception Messages
```csharp
// âœ… Correct
throw new ArgumentException(ErrorMessages.AmountCannotBeNegative, nameof(amount));

// âŒ Wrong
throw new Exception("Amount cannot be negative");
```

### Test Pattern
```csharp
[Test]
public void MethodName_Scenario_ExpectedResult()
{
    // Arrange
    // Act
    // Assert
}
```

### Validation Pattern
```csharp
public void Method(int value)
{
    if (value < 0)
        throw new ArgumentException(ErrorMessages.ValueCannotBeNegative, nameof(value));
    
    // Main logic
}
```

## ğŸ“ Key Files Reference

| Need | Read |
|------|------|
| Project state | `.ai/context.md` |
| Coding rules | `docs/project_guidelines.md` |
| What NOT to do | `docs/anti-patterns.md` |
| Code examples | `docs/examples/good_code.md` |
| Test examples | `docs/examples/good_tests.md` |
| Pre-implementation | `docs/checklists/pre_implementation.md` |
| Feature checklist | `docs/checklists/feature_complete.md` |
| Combat specs | `docs/architecture/combat_system_spec.md` |
| Damage formula | `docs/architecture/damage_and_effect_system.md` |

## ğŸ”„ After Completing Work

Always:
1. Run `dotnet build` - Verify no warnings
2. Run `dotnet test` - Verify all pass
3. Update `.ai/context.md` if major changes
4. Mention test count in response

## ğŸ® Project-Specific Knowledge

### Type Effectiveness
- Gen 6+ chart (Fairy included)
- STAB = 1.5x multiplier
- Dual-type multiplies

### Stat Calculation  
- Gen 3+ formula
- HP formula different from other stats
- Nature = 0.9, 1.0, or 1.1 modifier

### Pokemon Data
- Blueprints in `Content/Catalogs/Pokemon/`
- Moves in `Content/Catalogs/Moves/`
- Effects implement `IMoveEffect`

### Current Phase
- âœ… Phase 1: Core Data (Complete)
- âœ… Phase 2: Instances (Complete)  
- ğŸ¯ Phase 3: Combat System (Next)
