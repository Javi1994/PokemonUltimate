using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using PokemonUltimate.Combat.Actions.Validation;
using PokemonUltimate.Combat.Field;
using PokemonUltimate.Combat.View.Definition;
using PokemonUltimate.Core.Data.Blueprints;
using PokemonUltimate.Core.Domain.Instances.Move;

namespace PokemonUltimate.Combat.Actions
{
    /// <summary>
    /// Represents the intent to use a move in battle.
    /// This is now a data holder - execution is handled by turn steps.
    /// </summary>
    /// <remarks>
    /// **Feature**: 2: Combat System
    /// **Sub-Feature**: 2.5: Combat Actions
    /// **Documentation**: See `docs/features/2-combat-system/2.5-combat-actions/architecture.md` and `DECOUPLED_STEPS_PROPOSAL.md`
    ///
    /// **Note**: Execution logic has been moved to turn steps (MoveValidationStep, MoveDamageCalculationStep, etc.).
    /// This action now only holds data about the move intent.
    /// </remarks>
    public class UseMoveAction : BattleAction
    {

        /// <summary>
        /// The target slot for this move.
        /// </summary>
        public BattleSlot Target { get; }

        /// <summary>
        /// The move instance being used.
        /// </summary>
        public MoveInstance MoveInstance { get; }

        /// <summary>
        /// The move data blueprint.
        /// </summary>
        public MoveData Move => MoveInstance.Move;

        /// <summary>
        /// Priority override from the move data.
        /// </summary>
        public override int Priority => Move.Priority;

        /// <summary>
        /// Moves can be blocked by effects like Protect.
        /// </summary>
        public override bool CanBeBlocked => true;

        /// <summary>
        /// Creates a new use move action.
        /// This is now a simple data holder - execution is handled by turn steps.
        /// </summary>
        /// <param name="user">The slot using the move. Cannot be null.</param>
        /// <param name="target">The target slot. Cannot be null.</param>
        /// <param name="moveInstance">The move instance to use. Cannot be null.</param>
        /// <exception cref="ArgumentNullException">If user, target, or moveInstance is null.</exception>
        public UseMoveAction(
            BattleSlot user,
            BattleSlot target,
            MoveInstance moveInstance) : base(user)
        {
            ActionValidators.ValidateUser(user, nameof(user));
            ActionValidators.ValidateTargetNotNull(target, nameof(target));
            ActionValidators.ValidateMoveInstance(moveInstance, nameof(moveInstance));

            Target = target;
            MoveInstance = moveInstance;
        }

        /// <summary>
        /// Executes the move logic.
        ///
        /// **Note**: This method now returns empty because execution is handled by turn steps.
        /// The turn steps (MoveValidationStep, MoveDamageCalculationStep, etc.) process
        /// UseMoveAction instances and generate the appropriate actions.
        /// </summary>
        /// <param name="field">The battlefield. Cannot be null.</param>
        /// <returns>Empty list - execution is handled by turn steps.</returns>
        public override IEnumerable<BattleAction> ExecuteLogic(BattleField field)
        {
            ActionValidators.ValidateField(field);

            // Execution is now handled by turn steps:
            // - MoveValidationStep validates the move
            // - MoveDamageCalculationStep calculates damage
            // - MoveDamageApplicationStep applies damage
            // - MoveEffectProcessingStep processes move effects
            // etc.

            // Return empty - no actions should be generated here
            // Actions are generated by the turn steps that process UseMoveAction
            return new List<BattleAction>();
        }

        /// <summary>
        /// Plays the move animation.
        /// </summary>
        public override Task ExecuteVisual(IBattleView view)
        {
            ActionValidators.ValidateView(view);

            // Don't play animation if user or target are not valid/active
            // This prevents showing animations for moves that were queued but can't execute
            if (!ActionValidators.ValidateUserAndTargetForVisual(User, Target))
                return Task.CompletedTask;

            return view.PlayMoveAnimation(User, Target, Move.Id);
        }
    }
}

