# Battle Actions

The action system implements the Command pattern to represent all battle commands. Actions are the primary way battle logic communicates with the game state.

## Architecture

All actions inherit from `BattleAction` and follow a **two-phase execution pattern**:

1. **Logic Phase** (`ExecuteLogic()`): Instant game state updates (HP, status, stats, etc.)
2. **Visual Phase** (`ExecuteVisual()`): Async presentation to the player (animations, messages, UI updates)

Actions can generate **reaction actions** that are processed immediately (e.g., Damage â†’ Faint).

## Complete Action List

| Class                         | Purpose                    | Properties                           | Generates               |
| ----------------------------- | -------------------------- | ------------------------------------ | ----------------------- |
| **BattleAction.cs**           | Base class for all actions | User, Priority, CanBeBlocked         | -                       |
| **UseMoveAction.cs**          | Pokemon uses a move        | Move, User, Target                   | Damage, status, effects |
| **DamageAction.cs**           | Applies damage to target   | Target, Damage, DamageType           | FaintAction (if HP=0)   |
| **ContactDamageAction.cs**    | Contact-based damage       | Inherits DamageAction + contact flag | Contact effects         |
| **ApplyStatusAction.cs**      | Applies status condition   | Target, Status                       | -                       |
| **FaintAction.cs**            | Handles Pokemon fainting   | Target                               | Battle end check        |
| **HealAction.cs**             | Heals Pokemon              | Target, HealAmount                   | -                       |
| **StatChangeAction.cs**       | Modifies stat stages       | Target, StatType, Stages             | -                       |
| **SetWeatherAction.cs**       | Sets battlefield weather   | Weather, Duration                    | Weather effects         |
| **SetTerrainAction.cs**       | Sets battlefield terrain   | Terrain, Duration                    | Terrain effects         |
| **SetSideConditionAction.cs** | Sets side conditions       | Side, Condition, Duration            | -                       |
| **SwitchAction.cs**           | Switches Pokemon           | User, NewPokemon, TargetSlot         | Switch-in effects       |
| **MessageAction.cs**          | Displays battle message    | Message, User                        | -                       |

### Validation

| Class                   | Purpose                      | Methods                                                                     |
| ----------------------- | ---------------------------- | --------------------------------------------------------------------------- |
| **ActionValidators.cs** | Validation logic for actions | ValidateMove, ValidateStatusApplication, ValidateSwitch, ValidateStatChange |

## Action Processing Flow

Actions are processed by `BattleQueueService`:

1. **Enqueue**: Actions added to queue
2. **Logic Execution**: `ExecuteLogic()` called, returns reaction actions
3. **Reaction Insertion**: Reactions inserted at front of queue
4. **Visual Execution**: `ExecuteVisual()` called async
5. **Repeat**: Process continues until queue is empty

## Action Generation

Actions are generated by:

-   **Action Providers**: Player input, AI decisions
-   **Handlers**: Abilities, items, move effects
-   **Steps**: Turn flow steps generate actions
-   **Other Actions**: Actions can generate reaction actions

## How to Add a New Action Type

### Step 1: Create the Action Class

Create a new file in `Actions/` (e.g., `CustomAction.cs`):

```csharp
using System.Collections.Generic;
using System.Threading.Tasks;
using PokemonUltimate.Combat.Field;
using PokemonUltimate.Combat.View.Definition;

namespace PokemonUltimate.Combat.Actions
{
    public class CustomAction : BattleAction
    {
        private readonly BattleSlot _target;
        private readonly int _customValue;

        public CustomAction(BattleSlot user, BattleSlot target, int customValue)
            : base(user)
        {
            _target = target;
            _customValue = customValue;
        }

        public override IEnumerable<BattleAction> ExecuteLogic(BattleField field)
        {
            var reactions = new List<BattleAction>();

            // Your logic here
            // Update game state
            // Generate reaction actions if needed

            return reactions;
        }

        public override async Task ExecuteVisual(IBattleView view)
        {
            // Your visual presentation here
            // Show animations, messages, UI updates
            await Task.CompletedTask;
        }
    }
}
```

### Step 2: Add Validation (if needed)

If your action needs validation, add methods to `Actions/Validation/ActionValidators.cs`:

```csharp
public static class ActionValidators
{
    // ... existing validators ...

    public static ValidationResult ValidateCustomAction(CustomAction action, BattleField field)
    {
        // Your validation logic here
        return new ValidationResult { CanExecute = true };
    }
}
```

### Step 3: Use the Action

Generate your action from handlers, steps, or other actions:

```csharp
// In a handler or step
var customAction = new CustomAction(userSlot, targetSlot, value);
actions.Add(customAction);
```

### Step 4: Test the Action

Create unit tests for your action:

```csharp
[Test]
public void CustomAction_ExecutesLogic()
{
    // Arrange
    var action = new CustomAction(userSlot, targetSlot, 10);
    var field = CreateTestField();

    // Act
    var reactions = action.ExecuteLogic(field);

    // Assert
    // Verify expected behavior
}

[Test]
public async Task CustomAction_ExecutesVisual()
{
    // Arrange
    var action = new CustomAction(userSlot, targetSlot, 10);
    var view = CreateMockView();

    // Act
    await action.ExecuteVisual(view);

    // Assert
    // Verify visual presentation
}
```

## Action Priority Reference

Common action priorities:

-   **+7**: Switching (highest priority)
-   **+6**: Mega Evolution
-   **+5**: Using items
-   **+4**: Using Z-Moves
-   **+3**: Using Dynamax
-   **+1**: Quick Attack, Extreme Speed, etc.
-   **0**: Most moves (default)
-   **-1**: Vital Throw
-   **-5**: Counter, Mirror Coat
-   **-6**: Focus Punch
-   **-7**: Revenge, Avalanche (lowest priority)

## Design Principles

1. **Command Pattern**: Actions encapsulate battle commands
2. **Two-Phase Execution**: Logic and visual separation
3. **Reaction System**: Actions generate immediate reactions
4. **Immutability**: Actions are immutable once created
5. **Testability**: Actions can be tested independently

## Usage Example

```csharp
// Create a damage action
var damageAction = new DamageAction(
    user: attackerSlot,
    target: defenderSlot,
    damage: 50,
    damageType: DamageType.Physical
);

// Execute logic (instant)
var reactions = damageAction.ExecuteLogic(field);
// reactions might contain FaintAction if HP reaches 0

// Execute visual (async)
await damageAction.ExecuteVisual(view);
```

## Related Documentation

-   `../Engine/README.md` - Engine overview
-   `../Engine/TurnFlow/Steps/README.md` - Turn steps that generate actions
-   `../Handlers/README.md` - Handlers that generate actions
-   `../Engine/Service/BattleQueueService.cs` - Action queue processing
