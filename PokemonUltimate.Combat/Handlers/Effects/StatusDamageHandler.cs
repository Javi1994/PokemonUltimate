using System;
using System.Collections.Generic;
using PokemonUltimate.Combat.Actions;
using PokemonUltimate.Combat.Field;
using PokemonUltimate.Combat.Infrastructure.Factories;
using PokemonUltimate.Core.Data.Enums;
using PokemonUltimate.Core.Domain.Instances.Pokemon;
using PokemonUltimate.Localization.Constants;
using PokemonUltimate.Localization.Extensions;
using PokemonUltimate.Localization.Services;

namespace PokemonUltimate.Combat.Handlers.Effects
{
    /// <summary>
    /// Handler para procesar da√±o de status al final del turno (Burn, Poison, Badly Poisoned).
    /// </summary>
    /// <remarks>
    /// **Feature**: 2: Combat System
    /// **Sub-Feature**: 2.8: End-of-Turn Effects
    /// **Documentation**: See `RESPONSIBILITY_REVIEW.md`
    /// </remarks>
    public class StatusDamageHandler
    {
        private readonly DamageContextFactory _damageContextFactory;

        /// <summary>
        /// Creates a new StatusDamageHandler.
        /// </summary>
        /// <param name="damageContextFactory">Factory for creating damage contexts. Cannot be null.</param>
        public StatusDamageHandler(DamageContextFactory damageContextFactory)
        {
            _damageContextFactory = damageContextFactory ?? throw new ArgumentNullException(nameof(damageContextFactory));
        }

        /// <summary>
        /// Processes status damage for a single Pokemon slot.
        /// </summary>
        /// <param name="slot">The slot to process. Cannot be null.</param>
        /// <param name="field">The battlefield. Cannot be null.</param>
        /// <returns>List of actions generated by status damage.</returns>
        public List<BattleAction> ProcessStatusDamage(BattleSlot slot, BattleField field)
        {
            if (slot == null)
                throw new ArgumentNullException(nameof(slot));
            if (field == null)
                throw new ArgumentNullException(nameof(field));

            var actions = new List<BattleAction>();
            var pokemon = slot.Pokemon;

            if (pokemon == null)
                return actions;

            switch (pokemon.Status)
            {
                case PersistentStatus.Burn:
                    actions.AddRange(ProcessBurn(slot, field));
                    break;

                case PersistentStatus.Poison:
                    actions.AddRange(ProcessPoison(slot, field));
                    break;

                case PersistentStatus.BadlyPoisoned:
                    actions.AddRange(ProcessBadlyPoisoned(slot, field));
                    break;

                case PersistentStatus.None:
                case PersistentStatus.Paralysis:
                case PersistentStatus.Sleep:
                case PersistentStatus.Freeze:
                    // No end-of-turn damage for these
                    break;
            }

            return actions;
        }

        /// <summary>
        /// Processes Burn status: deals 1/16 Max HP damage.
        /// </summary>
        private List<BattleAction> ProcessBurn(BattleSlot slot, BattleField field)
        {
            var actions = new List<BattleAction>();
            var pokemon = slot.Pokemon;

            int damage = CalculateBurnDamage(pokemon.MaxHP);
            var provider = LocalizationService.Instance;
            actions.Add(new MessageAction(provider.GetString(LocalizationKey.StatusBurnDamage, pokemon.DisplayName)));
            actions.Add(CreateStatusDamageAction(slot, field, damage));

            return actions;
        }

        /// <summary>
        /// Processes Poison status: deals 1/8 Max HP damage.
        /// </summary>
        private List<BattleAction> ProcessPoison(BattleSlot slot, BattleField field)
        {
            var actions = new List<BattleAction>();
            var pokemon = slot.Pokemon;

            int damage = CalculatePoisonDamage(pokemon.MaxHP);
            var provider = LocalizationService.Instance;
            actions.Add(new MessageAction(provider.GetString(LocalizationKey.StatusPoisonDamage, pokemon.DisplayName)));
            actions.Add(CreateStatusDamageAction(slot, field, damage));

            return actions;
        }

        /// <summary>
        /// Processes Badly Poisoned (Toxic) status: deals escalating damage and increments counter.
        /// Damage formula: (counter * Max HP) / 16, counter increments each turn.
        /// </summary>
        private List<BattleAction> ProcessBadlyPoisoned(BattleSlot slot, BattleField field)
        {
            var actions = new List<BattleAction>();
            var pokemon = slot.Pokemon;

            // Ensure counter is at least 1 (initial value)
            int currentCounter = pokemon.StatusTurnCounter;
            if (currentCounter < 1)
                currentCounter = 1;

            // Calculate damage: (counter * Max HP) / 16, minimum 1
            int damage = (currentCounter * pokemon.MaxHP) / 16;
            damage = Math.Max(1, damage);

            // Increment counter for next turn
            pokemon.StatusTurnCounter = currentCounter + 1;

            var provider = LocalizationService.Instance;
            actions.Add(new MessageAction(provider.GetString(LocalizationKey.StatusPoisonDamage, pokemon.DisplayName)));
            actions.Add(CreateStatusDamageAction(slot, field, damage));

            return actions;
        }

        /// <summary>
        /// Calculates Burn damage: 1/16 of Max HP (minimum 1).
        /// </summary>
        private int CalculateBurnDamage(int maxHP)
        {
            int damage = maxHP / 16;
            return Math.Max(1, damage);
        }

        /// <summary>
        /// Calculates Poison damage: 1/8 of Max HP (minimum 1).
        /// </summary>
        private int CalculatePoisonDamage(int maxHP)
        {
            int damage = maxHP / 8;
            return Math.Max(1, damage);
        }

        /// <summary>
        /// Creates a DamageAction for status damage using DamageContextFactory.
        /// </summary>
        private DamageAction CreateStatusDamageAction(BattleSlot slot, BattleField field, int damage)
        {
            var context = _damageContextFactory.CreateForStatusDamage(slot, damage, field);
            return new DamageAction(slot, slot, context);
        }
    }
}
