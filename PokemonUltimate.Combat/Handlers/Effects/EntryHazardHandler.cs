using System;
using System.Collections.Generic;
using PokemonUltimate.Combat.Actions;
using PokemonUltimate.Combat.Field;
using PokemonUltimate.Combat.Handlers.Registry;
using PokemonUltimate.Combat.Infrastructure.Factories;
using PokemonUltimate.Content.Catalogs.Field;
using PokemonUltimate.Core.Data.Blueprints;
using PokemonUltimate.Core.Data.Enums;
using PokemonUltimate.Core.Domain.Instances.Pokemon;
using PokemonUltimate.Core.Services;
using PokemonUltimate.Localization.Constants;
using PokemonUltimate.Localization.Extensions;
using PokemonUltimate.Localization.Services;

namespace PokemonUltimate.Combat.Handlers.Effects
{
    /// <summary>
    /// Handler para procesar entry hazards cuando un Pokemon cambia (Spikes, Stealth Rock, Toxic Spikes, Sticky Web).
    /// </summary>
    /// <remarks>
    /// **Feature**: 2: Combat System
    /// **Sub-Feature**: 2.14: Hazards System
    /// **Documentation**: See `RESPONSIBILITY_REVIEW.md`
    /// </remarks>
    public class EntryHazardHandler
    {
        private readonly DamageContextFactory _damageContextFactory;
        private readonly CombatEffectHandlerRegistry _handlerRegistry;

        /// <summary>
        /// Creates a new EntryHazardHandler.
        /// </summary>
        /// <param name="damageContextFactory">Factory for creating damage contexts. Cannot be null.</param>
        /// <param name="handlerRegistry">Handler registry for stat change reversal. Cannot be null.</param>
        public EntryHazardHandler(DamageContextFactory damageContextFactory, CombatEffectHandlerRegistry handlerRegistry)
        {
            _damageContextFactory = damageContextFactory ?? throw new ArgumentNullException(nameof(damageContextFactory));
            _handlerRegistry = handlerRegistry ?? throw new ArgumentNullException(nameof(handlerRegistry));
        }

        /// <summary>
        /// Processes all entry hazards on the opposing side when a Pokemon switches in.
        /// </summary>
        /// <param name="slot">The slot the Pokemon is switching into. Cannot be null.</param>
        /// <param name="pokemon">The Pokemon switching in. Cannot be null.</param>
        /// <param name="field">The battlefield. Cannot be null.</param>
        /// <returns>List of actions generated by entry hazards.</returns>
        public List<BattleAction> ProcessHazards(BattleSlot slot, PokemonInstance pokemon, BattleField field)
        {
            if (slot == null)
                throw new ArgumentNullException(nameof(slot));
            if (pokemon == null)
                throw new ArgumentNullException(nameof(pokemon));
            if (field == null)
                throw new ArgumentNullException(nameof(field));

            var actions = new List<BattleAction>();
            var opposingSide = field.GetOppositeSide(slot.Side);
            Func<HazardType, HazardData> getHazardData = HazardCatalog.GetByType;

            // Process each hazard type
            ProcessSpikes(opposingSide, slot, pokemon, field, getHazardData, actions);
            ProcessStealthRock(opposingSide, slot, pokemon, field, getHazardData, actions);
            ProcessToxicSpikes(opposingSide, slot, pokemon, field, getHazardData, actions);
            ProcessStickyWeb(opposingSide, slot, pokemon, field, getHazardData, actions);

            return actions;
        }

        /// <summary>
        /// Processes Spikes hazard.
        /// </summary>
        private void ProcessSpikes(BattleSide side, BattleSlot slot, PokemonInstance pokemon, BattleField field, Func<HazardType, HazardData> getHazardData, List<BattleAction> actions)
        {
            if (!side.HasHazard(HazardType.Spikes))
                return;

            var hazardData = getHazardData(HazardType.Spikes);
            if (hazardData == null)
                return;

            // Check if Pokemon is affected (not Flying, not Levitate)
            if (!hazardData.AffectsPokemon(pokemon.Species.PrimaryType, pokemon.Species.SecondaryType, pokemon.Ability?.Name))
                return;

            int layers = side.GetHazardLayers(HazardType.Spikes);
            float damageFraction = hazardData.GetDamage(layers);
            int damage = CalculateHazardDamage(pokemon.MaxHP, damageFraction);

            if (damage > 0)
            {
                var provider = LocalizationService.Instance;
                var hazardName = hazardData.GetDisplayName(provider);
                actions.Add(new MessageAction(provider.GetString(LocalizationKey.HazardSpikesDamage, pokemon.DisplayName, hazardName)));
                actions.Add(CreateHazardDamageAction(slot, field, damage));
            }
        }

        /// <summary>
        /// Processes Stealth Rock hazard.
        /// </summary>
        private void ProcessStealthRock(BattleSide side, BattleSlot slot, PokemonInstance pokemon, BattleField field, Func<HazardType, HazardData> getHazardData, List<BattleAction> actions)
        {
            if (!side.HasHazard(HazardType.StealthRock))
                return;

            var hazardData = getHazardData(HazardType.StealthRock);
            if (hazardData == null)
                return;

            // Stealth Rock affects all Pokemon (including Flying)
            // Calculate type effectiveness vs Rock
            float effectiveness = CalculateTypeEffectiveness(
                hazardData.DamageType.Value,
                pokemon.Species.PrimaryType,
                pokemon.Species.SecondaryType);

            float baseDamageFraction = hazardData.GetDamage(1); // Always 1 layer
            float damageFraction = baseDamageFraction * effectiveness;
            int damage = CalculateHazardDamage(pokemon.MaxHP, damageFraction);

            if (damage > 0)
            {
                var provider = LocalizationService.Instance;
                var hazardName = hazardData.GetDisplayName(provider);
                actions.Add(new MessageAction(provider.GetString(LocalizationKey.HazardStealthRockDamage, pokemon.DisplayName, hazardName)));
                actions.Add(CreateHazardDamageAction(slot, field, damage));
            }
        }

        /// <summary>
        /// Processes Toxic Spikes hazard.
        /// </summary>
        private void ProcessToxicSpikes(BattleSide side, BattleSlot slot, PokemonInstance pokemon, BattleField field, Func<HazardType, HazardData> getHazardData, List<BattleAction> actions)
        {
            if (!side.HasHazard(HazardType.ToxicSpikes))
                return;

            var hazardData = getHazardData(HazardType.ToxicSpikes);
            if (hazardData == null)
                return;

            // Check if Poison type absorbs (removes spikes)
            if (hazardData.IsPoisonAbsorber(pokemon.Species.PrimaryType, pokemon.Species.SecondaryType))
            {
                side.RemoveHazard(HazardType.ToxicSpikes);
                var provider = LocalizationService.Instance;
                var hazardName = hazardData.GetDisplayName(provider);
                actions.Add(new MessageAction(provider.GetString(LocalizationKey.HazardToxicSpikesAbsorbed, pokemon.DisplayName, hazardName)));
                return;
            }

            // Check if Pokemon is affected (not Flying, not Levitate)
            if (!hazardData.AffectsPokemon(pokemon.Species.PrimaryType, pokemon.Species.SecondaryType, pokemon.Ability?.Name))
                return;

            int layers = side.GetHazardLayers(HazardType.ToxicSpikes);
            PersistentStatus status = hazardData.GetStatus(layers);

            if (status != PersistentStatus.None)
            {
                var provider = LocalizationService.Instance;
                var hazardName = hazardData.GetDisplayName(provider);
                actions.Add(new MessageAction(provider.GetString(LocalizationKey.HazardToxicSpikesStatus, pokemon.DisplayName, hazardName)));
                actions.Add(new ApplyStatusAction(null, slot, status));
            }
        }

        /// <summary>
        /// Processes Sticky Web hazard.
        /// </summary>
        private void ProcessStickyWeb(BattleSide side, BattleSlot slot, PokemonInstance pokemon, BattleField field, Func<HazardType, HazardData> getHazardData, List<BattleAction> actions)
        {
            if (!side.HasHazard(HazardType.StickyWeb))
                return;

            var hazardData = getHazardData(HazardType.StickyWeb);
            if (hazardData == null)
                return;

            // Check if Pokemon is affected (not Flying, not Levitate)
            if (!hazardData.AffectsPokemon(pokemon.Species.PrimaryType, pokemon.Species.SecondaryType, pokemon.Ability?.Name))
                return;

            if (hazardData.LowersStat)
            {
                int stages = hazardData.StatStages;

                // Use Handler to reverse stat changes if Pokemon has Contrary (eliminates hardcoding)
                var reversalHandler = _handlerRegistry.GetStatChangeReversalHandler();
                stages = reversalHandler.ReverseStatChange(pokemon, stages);

                var provider = LocalizationService.Instance;
                var hazardName = hazardData.GetDisplayName(provider);
                actions.Add(new MessageAction(provider.GetString(LocalizationKey.HazardStickyWebSpeed, pokemon.DisplayName, hazardName)));
                actions.Add(new StatChangeAction(null, slot, hazardData.StatToLower.Value, stages));
            }
        }

        /// <summary>
        /// Calculates type effectiveness for a defending Pokemon.
        /// </summary>
        private float CalculateTypeEffectiveness(PokemonType attackingType, PokemonType primaryType, PokemonType? secondaryType)
        {
            float effectiveness1 = TypeEffectivenessService.GetEffectiveness(attackingType, primaryType);
            float effectiveness2 = secondaryType.HasValue
                ? TypeEffectivenessService.GetEffectiveness(attackingType, secondaryType.Value)
                : 1.0f;

            return effectiveness1 * effectiveness2;
        }

        /// <summary>
        /// Calculates hazard damage based on max HP and damage fraction.
        /// </summary>
        private int CalculateHazardDamage(int maxHP, float damageFraction)
        {
            int damage = (int)(maxHP * damageFraction);
            return Math.Max(1, damage); // Minimum 1 damage
        }

        /// <summary>
        /// Creates a DamageAction for hazard damage.
        /// </summary>
        private DamageAction CreateHazardDamageAction(BattleSlot slot, BattleField field, int damage)
        {
            var context = _damageContextFactory.CreateForHazardDamage(slot, damage, field);
            return new DamageAction(null, slot, context); // null user = system action
        }
    }
}
