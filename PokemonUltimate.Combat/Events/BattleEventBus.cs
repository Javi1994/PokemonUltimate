using System;
using System.Collections.Generic;
using System.Linq;
using PokemonUltimate.Combat.Actions;

namespace PokemonUltimate.Combat.Events
{
    /// <summary>
    /// Unified event bus for all battle events.
    /// Handles both BattleTrigger events (abilities/items) and BattleEvent events (statistics/logging).
    /// </summary>
    /// <remarks>
    /// **Feature**: 2: Combat System
    /// **Sub-Feature**: 2.9: Abilities & Items, 2.20: Statistics System
    /// **Documentation**: See `docs/features/2-combat-system/2.9-abilities-items/architecture.md` and `docs/features/2-combat-system/2.20-statistics-system/architecture.md`
    /// </remarks>
    public class BattleEventBus : IBattleEventBus
    {
        // BattleTrigger subscriptions (for abilities/items)
        private readonly Dictionary<BattleTrigger, List<IBattleListener>> _triggerSubscriptions = new Dictionary<BattleTrigger, List<IBattleListener>>();

        // BattleEvent subscriptions (for statistics/logging)
        private readonly List<IBattleEventSubscriber> _eventSubscribers = new List<IBattleEventSubscriber>();

        // ===== BattleTrigger Methods =====

        /// <summary>
        /// Subscribes a listener to a specific battle trigger.
        /// </summary>
        /// <param name="trigger">The trigger to subscribe to.</param>
        /// <param name="listener">The listener to subscribe. Cannot be null.</param>
        /// <exception cref="ArgumentNullException">If listener is null.</exception>
        public void Subscribe(BattleTrigger trigger, IBattleListener listener)
        {
            if (listener == null)
                throw new ArgumentNullException(nameof(listener));

            if (!_triggerSubscriptions.ContainsKey(trigger))
            {
                _triggerSubscriptions[trigger] = new List<IBattleListener>();
            }

            // Only add if not already subscribed
            if (!_triggerSubscriptions[trigger].Contains(listener))
            {
                _triggerSubscriptions[trigger].Add(listener);
            }
        }

        /// <summary>
        /// Unsubscribes a listener from a specific battle trigger.
        /// </summary>
        /// <param name="trigger">The trigger to unsubscribe from.</param>
        /// <param name="listener">The listener to unsubscribe. Cannot be null.</param>
        /// <exception cref="ArgumentNullException">If listener is null.</exception>
        public void Unsubscribe(BattleTrigger trigger, IBattleListener listener)
        {
            if (listener == null)
                throw new ArgumentNullException(nameof(listener));

            if (_triggerSubscriptions.ContainsKey(trigger))
            {
                _triggerSubscriptions[trigger].Remove(listener);
            }
        }

        /// <summary>
        /// Unsubscribes a listener from all triggers.
        /// </summary>
        /// <param name="listener">The listener to unsubscribe. Cannot be null.</param>
        /// <exception cref="ArgumentNullException">If listener is null.</exception>
        public void UnsubscribeAll(IBattleListener listener)
        {
            if (listener == null)
                throw new ArgumentNullException(nameof(listener));

            foreach (var trigger in _triggerSubscriptions.Keys.ToList())
            {
                _triggerSubscriptions[trigger].Remove(listener);
            }
        }

        /// <summary>
        /// Publishes a battle trigger event and returns actions from all subscribed listeners.
        /// </summary>
        /// <param name="trigger">The trigger to publish.</param>
        /// <param name="field">The battlefield. Cannot be null.</param>
        /// <returns>Actions generated by all listeners subscribed to this trigger.</returns>
        /// <exception cref="ArgumentNullException">If field is null.</exception>
        public IEnumerable<BattleAction> Publish(BattleTrigger trigger, BattleField field)
        {
            if (field == null)
                throw new ArgumentNullException(nameof(field));

            var actions = new List<BattleAction>();

            if (!_triggerSubscriptions.ContainsKey(trigger))
                return actions;

            // Create a copy to avoid modification during iteration
            var listeners = _triggerSubscriptions[trigger].ToList();

            // Get all active slots to pass to listeners
            var activeSlots = field.GetAllActiveSlots().Where(slot => !slot.IsEmpty).ToList();

            foreach (var listener in listeners)
            {
                try
                {
                    // For each listener, call OnTrigger for each active slot
                    // This allows global listeners to react to all slots
                    foreach (var slot in activeSlots)
                    {
                        var listenerActions = listener.OnTrigger(trigger, slot, field);
                        actions.AddRange(listenerActions);
                    }
                }
                catch
                {
                    // Ignore errors from listeners to prevent one bad listener from breaking the system
                }
            }

            return actions;
        }

        // ===== BattleEvent Methods (for statistics/logging) =====

        /// <summary>
        /// Subscribes a component to receive battle events (statistics/logging).
        /// </summary>
        /// <param name="subscriber">The subscriber to add.</param>
        public void Subscribe(IBattleEventSubscriber subscriber)
        {
            if (subscriber != null && !_eventSubscribers.Contains(subscriber))
            {
                _eventSubscribers.Add(subscriber);
            }
        }

        /// <summary>
        /// Unsubscribes a component from receiving battle events.
        /// </summary>
        /// <param name="subscriber">The subscriber to remove.</param>
        public void Unsubscribe(IBattleEventSubscriber subscriber)
        {
            if (subscriber != null)
            {
                _eventSubscribers.Remove(subscriber);
            }
        }

        /// <summary>
        /// Publishes a battle event to all subscribers.
        /// </summary>
        /// <param name="event">The event to publish.</param>
        public void PublishEvent(BattleEvent @event)
        {
            if (@event == null)
                return;

            // Create a copy of subscribers list to avoid modification during iteration
            var subscribersCopy = _eventSubscribers.ToList();

            foreach (var subscriber in subscribersCopy)
            {
                try
                {
                    subscriber.OnBattleEvent(@event);
                }
                catch
                {
                    // Ignore errors from subscribers to prevent one bad subscriber from breaking the system
                }
            }
        }
    }
}
