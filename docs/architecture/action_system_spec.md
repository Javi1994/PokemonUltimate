# Action System Specification

> **Purpose**: Define exactly what a BattleAction is, when triggers fire, and how different systems inject actions into the battle flow.

---

## 1. Core Philosophy: Everything is an Action

The entire battle is a **linear sequence of Actions** processed by a **Queue**. This includes:

- Moves being used
- Damage being applied
- Status effects activating
- Abilities triggering
- Items activating
- Messages being displayed
- Animations playing

**Why?** This makes the flow predictable, testable, and extensible.

```
Turn Flow:
┌─────────────────────────────────────────────────────────────────┐
│ 1. Selection Phase   → Players choose actions                   │
│ 2. Sort Phase        → Actions sorted by priority/speed         │
│ 3. Execution Phase   → Queue processes actions one by one       │
│ 4. End of Turn       → Status damage, Abilities, Items trigger  │
│ 5. Victory Check     → Is battle over?                          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. BattleAction Anatomy

### Base Class

```csharp
public abstract class BattleAction
{
    /// <summary>
    /// Who initiated this action. Null for system actions (weather, etc).
    /// </summary>
    public BattleSlot User { get; }
    
    /// <summary>
    /// Priority for turn order. Higher = goes first.
    /// Most actions = 0, Quick Attack = +1, Vital Throw = -1.
    /// </summary>
    public virtual int Priority => 0;
    
    /// <summary>
    /// Can this action be cancelled/blocked? (e.g., by Protect)
    /// </summary>
    public virtual bool CanBeBlocked => false;
    
    /// <summary>
    /// Phase 1: Update game state instantly.
    /// Returns reaction actions (e.g., Damage → Faint).
    /// </summary>
    public abstract IEnumerable<BattleAction> ExecuteLogic(BattleField field);
    
    /// <summary>
    /// Phase 2: Show to player (animations, messages).
    /// </summary>
    public abstract Task ExecuteVisual(IBattleView view);
}
```

### Action Categories

| Category | Examples | Characteristics |
|----------|----------|-----------------|
| **Turn Actions** | UseMoveAction, SwitchAction, UseItemAction | Selected by player/AI, sorted by turn order |
| **Reaction Actions** | DamageAction, FaintAction, StatChangeAction | Generated by other actions, execute immediately |
| **System Actions** | WeatherDamageAction, HazardDamageAction | Generated by game state, not player input |
| **Presentation Actions** | MessageAction, AnimationAction | No logic, only visual/audio feedback |

---

## 3. Action Execution Flow

### 3.1 Queue Processing

```csharp
while (queue.Count > 0)
{
    var action = queue.Dequeue();
    
    // Step 1: Check if action can execute
    if (action.CanBeBlocked && IsBlocked(action))
    {
        // Action was blocked (e.g., by Protect)
        queue.InsertAtFront(new BlockedMessageAction(action));
        continue;
    }
    
    // Step 2: Fire PRE triggers
    await FireTriggers(BattleTrigger.BeforeAction, action);
    
    // Step 3: Execute logic (instant)
    var reactions = action.ExecuteLogic(field);
    
    // Step 4: Execute visual (async)
    await action.ExecuteVisual(view);
    
    // Step 5: Fire POST triggers
    await FireTriggers(BattleTrigger.AfterAction, action);
    
    // Step 6: Insert reactions at front (execute next)
    queue.InsertAtFront(reactions);
}
```

### 3.2 Reaction Chain Example

```
Player uses Thunderbolt on Gyarados:

Queue: [UseMoveAction(Thunderbolt)]

→ UseMoveAction executes:
  Returns: [MessageAction, AnimationAction, DamageAction]
  
Queue: [MessageAction, AnimationAction, DamageAction]

→ DamageAction executes (4x super effective, Gyarados faints):
  Returns: [FaintAction]
  
Queue: [FaintAction]

→ FaintAction executes:
  Returns: [ExpGainAction, ForceSwitchAction]
  
Queue: [ExpGainAction, ForceSwitchAction]
```

---

## 4. Trigger System

### 4.1 BattleTrigger Enum (Complete)

```csharp
public enum BattleTrigger
{
    // === TURN STRUCTURE ===
    OnTurnStart,           // Start of each turn
    OnTurnEnd,             // End of each turn (Leftovers, Poison damage)
    
    // === SWITCH EVENTS ===
    OnSwitchOut,           // Before Pokemon leaves field (Regenerator)
    OnSwitchIn,            // After Pokemon enters field (Intimidate, Hazards)
    
    // === MOVE EXECUTION ===
    OnBeforeMove,          // Before move executes (Truant check, Sleep check)
    OnMoveSelected,        // After selection, before execution (Pressure)
    OnMoveMiss,            // Move missed (Hustle)
    OnMoveHit,             // Move connected (Life Orb, Sheer Force)
    OnAfterMove,           // After move completes (Choice lock)
    
    // === DAMAGE EVENTS ===
    OnBeforeDamage,        // Before damage applied (Focus Sash check)
    OnDamageTaken,         // After damage applied (Anger Point, Berserk)
    OnDamageDealt,         // After dealing damage (Moxie)
    
    // === TYPE-SPECIFIC ===
    OnContactMade,         // Physical contact occurred (Static, Rough Skin)
    OnSuperEffective,      // Super effective hit (Expert Belt)
    OnNotVeryEffective,    // Resisted hit (Tinted Lens)
    OnCriticalHit,         // Critical hit landed (Sniper, Anger Point)
    OnOHKO,                // Would be knocked out (Sturdy, Focus Sash)
    
    // === STATUS EVENTS ===
    OnStatusAttempt,       // Before status applied (Limber, Immunity)
    OnStatusApplied,       // After status applied
    OnStatusRemoved,       // Status cured
    OnStatusTick,          // Each turn for status (Burn damage, Sleep counter)
    
    // === STAT EVENTS ===
    OnStatChangeAttempt,   // Before stat change (Clear Body, White Smoke)
    OnStatChanged,         // After stat changed (Competitive, Defiant)
    
    // === FIELD EVENTS ===
    OnWeatherStart,        // Weather begins
    OnWeatherEnd,          // Weather ends
    OnWeatherTick,         // Each turn in weather (Sand damage)
    OnTerrainStart,        // Terrain begins
    OnTerrainEnd,          // Terrain ends
    OnHazardSet,           // Hazard placed
    OnHazardCleared,       // Hazard removed
    
    // === BATTLE EVENTS ===
    OnBattleStart,         // Battle begins
    OnBattleEnd,           // Battle ends
    OnFaint,               // Pokemon faints
    OnRevive,              // Pokemon revived
    
    // === ITEM EVENTS ===
    OnItemUsed,            // Item consumed
    OnItemStolen,          // Item taken (Thief, Trick)
    OnBerryEaten,          // Berry activated
}
```

### 4.2 Trigger Timing Diagram

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         MOVE EXECUTION FLOW                              │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  OnBeforeMove                                                            │
│       │  ├─ Sleep/Freeze check (can wake up/thaw)                       │
│       │  ├─ Confusion check (can hit self)                              │
│       │  ├─ Paralysis check (can be fully paralyzed)                    │
│       │  ├─ Flinch check (consumed here)                                │
│       │  └─ Truant check (ability)                                      │
│       ▼                                                                  │
│  [If failed, move ends here]                                            │
│       │                                                                  │
│       ▼                                                                  │
│  Accuracy Check                                                          │
│       │                                                                  │
│       ├─ OnMoveMiss (if missed)                                         │
│       │       └─ "Attack missed!" message                               │
│       │                                                                  │
│       └─ OnMoveHit (if hit)                                             │
│               │                                                          │
│               ▼                                                          │
│          OnBeforeDamage ←─ Focus Sash/Sturdy check here                 │
│               │                                                          │
│               ▼                                                          │
│          [Damage Applied]                                                │
│               │                                                          │
│               ├─ OnDamageTaken (defender)                               │
│               │       ├─ Static/Rough Skin (OnContactMade)              │
│               │       ├─ Anger Point (OnCriticalHit)                    │
│               │       └─ Berserk (HP < 50%)                             │
│               │                                                          │
│               ├─ OnDamageDealt (attacker)                               │
│               │       └─ Moxie (if KO)                                  │
│               │                                                          │
│               └─ OnOHKO (if HP would reach 0)                           │
│                       ├─ Focus Sash activates                           │
│                       └─ Sturdy activates                               │
│                                                                          │
│  OnAfterMove                                                             │
│       ├─ Move recoil (RecoilEffect) ✅                                  │
│       ├─ Move drain (DrainEffect) ✅                                    │
│       ├─ Life Orb recoil                                                │
│       ├─ Choice item lock                                               │
│       └─ Shell Bell heal                                                │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 4.3 End of Turn Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         END OF TURN FLOW                                 │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  1. WEATHER DAMAGE (in speed order)                                     │
│       ├─ Sandstorm (not Rock/Ground/Steel)                              │
│       └─ Hail (not Ice)                                                 │
│                                                                          │
│  2. FUTURE SIGHT / DOOM DESIRE (lands after 2 turns)                    │
│                                                                          │
│  3. WISH (heals after 1 turn)                                           │
│                                                                          │
│  4. HEALING ABILITIES (Speed order)                                     │
│       ├─ Rain Dish (in Rain)                                            │
│       ├─ Dry Skin (in Rain)                                             │
│       ├─ Ice Body (in Hail)                                             │
│       └─ Shed Skin (chance to cure status)                              │
│                                                                          │
│  5. ITEM EFFECTS (Speed order)                                          │
│       ├─ Leftovers (+1/16 HP)                                           │
│       ├─ Black Sludge (+1/16 if Poison, damage otherwise)               │
│       └─ Berry triggers (if HP threshold met)                           │
│                                                                          │
│  6. ABILITY EFFECTS (Speed order)                                       │
│       ├─ Speed Boost (+1 Speed)                                         │
│       ├─ Moody (random +2/-1)                                           │
│       └─ Poison Heal (heal instead of damage)                           │
│                                                                          │
│  7. STATUS DAMAGE (Speed order)                                         │
│       ├─ Burn (1/16 HP, or 1/8 pre-Gen7)                               │
│       ├─ Poison (1/8 HP)                                                │
│       └─ Badly Poisoned (1/16 increasing)                               │
│                                                                          │
│  8. BINDING DAMAGE (Wrap, Bind, Fire Spin)                              │
│       └─ 1/8 HP per turn                                                │
│                                                                          │
│  9. CURSE DAMAGE (Ghost curse)                                          │
│       └─ 1/4 HP per turn                                                │
│                                                                          │
│  10. LEECH SEED (Speed order)                                           │
│       └─ 1/8 HP drained to seeder                                       │
│                                                                          │
│  11. NIGHTMARE (if Asleep)                                              │
│       └─ 1/4 HP per turn                                                │
│                                                                          │
│  12. PERISH COUNT (Perish Song)                                         │
│       └─ Counter decreases, faints at 0                                 │
│                                                                          │
│  13. FIELD EFFECT TIMERS                                                │
│       ├─ Reflect/Light Screen duration                                  │
│       ├─ Weather duration                                               │
│       ├─ Terrain duration                                               │
│       └─ Trick Room duration                                            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 5. Listener System

### 5.1 IBattleListener Interface

```csharp
/// <summary>
/// Implemented by Abilities, Items, and Status effects to respond to battle events.
/// </summary>
public interface IBattleListener
{
    /// <summary>
    /// Responds to a battle trigger and optionally returns actions to enqueue.
    /// </summary>
    /// <param name="trigger">The event that occurred</param>
    /// <param name="context">Full context about the trigger</param>
    /// <returns>Actions to add to the queue (empty if no response)</returns>
    IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext context);
}
```

### 5.2 TriggerContext (Rich Context)

```csharp
/// <summary>
/// Provides all relevant information about a trigger event.
/// </summary>
public class TriggerContext
{
    // WHO
    public BattleSlot Source { get; init; }      // Who caused the trigger
    public BattleSlot Target { get; init; }      // Who is affected
    public BattleSlot Holder { get; init; }      // Who holds this ability/item
    
    // WHAT
    public BattleAction Action { get; init; }    // The action that triggered this
    public MoveData Move { get; init; }          // Move being used (if applicable)
    public int Damage { get; init; }             // Damage dealt (if applicable)
    public PokemonType MoveType { get; init; }   // Type of move
    public bool WasCritical { get; init; }       // Was it a crit?
    public bool MadeContact { get; init; }       // Was contact made?
    public float TypeEffectiveness { get; init; }// Type multiplier
    
    // WHERE
    public BattleField Field { get; init; }      // Full battle state
    
    // MODIFIABLE (for interception)
    public bool ShouldCancel { get; set; }       // Set to true to cancel
    public int ModifiedDamage { get; set; }      // Modify damage amount
}
```

### 5.3 Listener Examples

#### Ability: Intimidate

```csharp
public class IntimidateAbility : IBattleListener
{
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        if (trigger != BattleTrigger.OnSwitchIn) yield break;
        if (ctx.Source != ctx.Holder) yield break; // Only when I switch in
        
        yield return new MessageAction($"{ctx.Holder.Pokemon.DisplayName}'s Intimidate!");
        
        var enemies = ctx.Field.GetOppositeSide(ctx.Holder.Side).GetActiveSlots();
        foreach (var enemy in enemies)
        {
            yield return new StatChangeAction(enemy, Stat.Attack, -1);
        }
    }
}
```

#### Ability: Static

```csharp
public class StaticAbility : IBattleListener
{
    private const float ParalysisChance = 0.30f;
    
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        if (trigger != BattleTrigger.OnContactMade) yield break;
        if (ctx.Target != ctx.Holder) yield break; // Only when I'm hit
        if (!ctx.MadeContact) yield break;
        
        if (Random.Shared.NextDouble() < ParalysisChance)
        {
            yield return new MessageAction($"{ctx.Source.Pokemon.DisplayName} was paralyzed by Static!");
            yield return new ApplyStatusAction(ctx.Source, PersistentStatus.Paralysis);
        }
    }
}
```

#### Ability: Sturdy (Interception)

```csharp
public class SturdyAbility : IBattleListener
{
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        if (trigger != BattleTrigger.OnOHKO) yield break;
        if (ctx.Target != ctx.Holder) yield break;
        
        // Only works at full HP
        if (ctx.Holder.Pokemon.CurrentHP != ctx.Holder.Pokemon.MaxHP) yield break;
        
        // Modify damage to leave 1 HP
        ctx.ModifiedDamage = ctx.Holder.Pokemon.CurrentHP - 1;
        
        yield return new MessageAction($"{ctx.Holder.Pokemon.DisplayName} held on with Sturdy!");
    }
}
```

#### Item: Focus Sash

```csharp
public class FocusSashItem : IBattleListener
{
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        if (trigger != BattleTrigger.OnOHKO) yield break;
        if (ctx.Target != ctx.Holder) yield break;
        
        // Only works at full HP
        if (ctx.Holder.Pokemon.CurrentHP != ctx.Holder.Pokemon.MaxHP) yield break;
        
        // Modify damage to leave 1 HP
        ctx.ModifiedDamage = ctx.Holder.Pokemon.CurrentHP - 1;
        
        yield return new MessageAction($"{ctx.Holder.Pokemon.DisplayName} held on using its Focus Sash!");
        yield return new ConsumeItemAction(ctx.Holder);
    }
}
```

#### Item: Leftovers

```csharp
public class LeftoversItem : IBattleListener
{
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        if (trigger != BattleTrigger.OnTurnEnd) yield break;
        
        var pokemon = ctx.Holder.Pokemon;
        if (pokemon.CurrentHP >= pokemon.MaxHP) yield break;
        
        int healAmount = Math.Max(1, pokemon.MaxHP / 16);
        
        yield return new MessageAction($"{pokemon.DisplayName}'s Leftovers restored its HP!");
        yield return new HealAction(ctx.Holder, healAmount);
    }
}
```

---

## 6. Status Condition System

### 6.1 Status as IBattleListener

Status conditions implement `IBattleListener` to inject their effects:

```csharp
public class BurnStatusListener : IBattleListener
{
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        var pokemon = ctx.Holder.Pokemon;
        if (pokemon.PersistentStatus != PersistentStatus.Burn) yield break;
        
        switch (trigger)
        {
            case BattleTrigger.OnTurnEnd:
                // Burn damage at end of turn
                int damage = Math.Max(1, pokemon.MaxHP / 16);
                yield return new MessageAction($"{pokemon.DisplayName} is hurt by its burn!");
                yield return new StatusDamageAction(ctx.Holder, damage, "Burn");
                break;
        }
    }
}

public class SleepStatusListener : IBattleListener
{
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        var pokemon = ctx.Holder.Pokemon;
        if (pokemon.PersistentStatus != PersistentStatus.Sleep) yield break;
        
        switch (trigger)
        {
            case BattleTrigger.OnBeforeMove:
                // Check if Pokemon wakes up
                if (TryWakeUp(pokemon))
                {
                    yield return new MessageAction($"{pokemon.DisplayName} woke up!");
                    yield return new CureStatusAction(ctx.Holder, PersistentStatus.Sleep);
                    // Continue with move (don't cancel)
                }
                else
                {
                    yield return new MessageAction($"{pokemon.DisplayName} is fast asleep.");
                    ctx.ShouldCancel = true; // Cancel the move
                }
                break;
        }
    }
}

public class ParalysisStatusListener : IBattleListener
{
    private const float FullParalysisChance = 0.25f;
    
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        var pokemon = ctx.Holder.Pokemon;
        if (pokemon.PersistentStatus != PersistentStatus.Paralysis) yield break;
        
        switch (trigger)
        {
            case BattleTrigger.OnBeforeMove:
                if (Random.Shared.NextDouble() < FullParalysisChance)
                {
                    yield return new MessageAction($"{pokemon.DisplayName} is fully paralyzed!");
                    ctx.ShouldCancel = true;
                }
                break;
        }
    }
}
```

### 6.2 Volatile Status (Confusion, Flinch, etc.)

```csharp
public class ConfusionListener : IBattleListener
{
    private const float SelfHitChance = 0.33f;
    
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        if (!ctx.Holder.HasVolatileStatus(VolatileStatus.Confusion)) yield break;
        
        switch (trigger)
        {
            case BattleTrigger.OnBeforeMove:
                // Check confusion snap-out
                if (TrySnapOut(ctx.Holder))
                {
                    yield return new MessageAction($"{ctx.Holder.Pokemon.DisplayName} snapped out of confusion!");
                    yield return new RemoveVolatileAction(ctx.Holder, VolatileStatus.Confusion);
                }
                else if (Random.Shared.NextDouble() < SelfHitChance)
                {
                    yield return new MessageAction($"{ctx.Holder.Pokemon.DisplayName} hurt itself in confusion!");
                    int damage = CalculateConfusionDamage(ctx.Holder);
                    yield return new SelfDamageAction(ctx.Holder, damage);
                    ctx.ShouldCancel = true;
                }
                break;
        }
    }
}

public class FlinchListener : IBattleListener
{
    public IEnumerable<BattleAction> OnTrigger(BattleTrigger trigger, TriggerContext ctx)
    {
        if (!ctx.Holder.HasVolatileStatus(VolatileStatus.Flinch)) yield break;
        
        switch (trigger)
        {
            case BattleTrigger.OnBeforeMove:
                yield return new MessageAction($"{ctx.Holder.Pokemon.DisplayName} flinched and couldn't move!");
                yield return new RemoveVolatileAction(ctx.Holder, VolatileStatus.Flinch);
                ctx.ShouldCancel = true;
                break;
                
            case BattleTrigger.OnTurnEnd:
                // Flinch always clears at end of turn
                yield return new RemoveVolatileAction(ctx.Holder, VolatileStatus.Flinch);
                break;
        }
    }
}
```

---

## 7. Interception Mechanism

### 7.1 The OnOHKO Pattern

When damage would knock out a Pokemon, we check for abilities/items that can prevent it:

```csharp
public class DamageAction : BattleAction
{
    public override IEnumerable<BattleAction> ExecuteLogic(BattleField field)
    {
        var pokemon = Target.Pokemon;
        int finalDamage = Amount;
        
        // Check if this would be a OHKO
        if (pokemon.CurrentHP - finalDamage <= 0 && pokemon.CurrentHP > 0)
        {
            // Create context for interception
            var ctx = new TriggerContext
            {
                Target = Target,
                Holder = Target,
                Damage = finalDamage,
                ModifiedDamage = finalDamage,
                Field = field
            };
            
            // Fire OnOHKO trigger to all listeners
            foreach (var listener in GetListeners(Target))
            {
                var actions = listener.OnTrigger(BattleTrigger.OnOHKO, ctx);
                foreach (var action in actions)
                {
                    yield return action;
                }
            }
            
            // Use modified damage (Focus Sash/Sturdy may have changed it)
            finalDamage = ctx.ModifiedDamage;
        }
        
        // Apply damage
        pokemon.CurrentHP = Math.Max(0, pokemon.CurrentHP - finalDamage);
        
        // Check for faint
        if (pokemon.CurrentHP <= 0)
        {
            yield return new FaintAction(Target);
        }
    }
}
```

### 7.2 The OnStatChangeAttempt Pattern

```csharp
public class StatChangeAction : BattleAction
{
    public override IEnumerable<BattleAction> ExecuteLogic(BattleField field)
    {
        var ctx = new TriggerContext
        {
            Target = Target,
            Holder = Target,
            Field = field,
            ShouldCancel = false
        };
        
        // Fire OnStatChangeAttempt
        foreach (var listener in GetListeners(Target))
        {
            var actions = listener.OnTrigger(BattleTrigger.OnStatChangeAttempt, ctx);
            foreach (var action in actions)
            {
                yield return action;
            }
        }
        
        // Clear Body, White Smoke can cancel negative changes
        if (ctx.ShouldCancel)
        {
            yield break;
        }
        
        // Apply stat change
        int actualChange = Target.ModifyStatStage(Stat, Stages);
        
        // Fire OnStatChanged (for Competitive, Defiant)
        if (actualChange != 0)
        {
            ctx = new TriggerContext { Target = Target, Field = field };
            foreach (var listener in GetListeners(Target))
            {
                var actions = listener.OnTrigger(BattleTrigger.OnStatChanged, ctx);
                foreach (var action in actions)
                {
                    yield return action;
                }
            }
        }
    }
}
```

---

## 8. Listener Resolution Order

When multiple listeners respond to the same trigger, order matters:

### 8.1 Priority Order

```
1. Speed Order (faster Pokemon first)
2. Within same speed: Player side first
3. Within same side: Slot order (0, 1, 2)
4. Within same slot: Ability → Item → Status
```

### 8.2 Implementation

```csharp
private async Task FireTriggers(BattleTrigger trigger, TriggerContext baseContext)
{
    var allListeners = new List<(int speed, bool isPlayer, int slot, int priority, IBattleListener listener, BattleSlot holder)>();
    
    // Collect all listeners
    foreach (var slot in field.GetAllActiveSlots().OrderByDescending(s => s.Pokemon.Speed))
    {
        // Ability (priority 0)
        if (slot.Pokemon.Ability is IBattleListener abilityListener)
        {
            allListeners.Add((slot.Pokemon.Speed, slot.Side.IsPlayer, slot.Index, 0, abilityListener, slot));
        }
        
        // Item (priority 1)
        if (slot.Pokemon.HeldItem is IBattleListener itemListener)
        {
            allListeners.Add((slot.Pokemon.Speed, slot.Side.IsPlayer, slot.Index, 1, itemListener, slot));
        }
        
        // Status listeners (priority 2)
        foreach (var statusListener in GetStatusListeners(slot))
        {
            allListeners.Add((slot.Pokemon.Speed, slot.Side.IsPlayer, slot.Index, 2, statusListener, slot));
        }
    }
    
    // Sort by: Speed DESC, IsPlayer DESC, Slot ASC, Priority ASC
    var sorted = allListeners
        .OrderByDescending(x => x.speed)
        .ThenByDescending(x => x.isPlayer)
        .ThenBy(x => x.slot)
        .ThenBy(x => x.priority);
    
    // Fire each listener
    foreach (var (_, _, _, _, listener, holder) in sorted)
    {
        var ctx = baseContext with { Holder = holder };
        var actions = listener.OnTrigger(trigger, ctx);
        
        foreach (var action in actions)
        {
            _queue.Enqueue(action);
        }
    }
    
    // Process any generated actions
    await _queue.ProcessQueue(field, view);
}
```

---

## 9. Complete Action Catalog

### 9.1 Turn Actions (Player/AI Selected)

| Action | Priority | CanBeBlocked | Description |
|--------|----------|--------------|-------------|
| `SwitchAction` | +6 | No | Switch to another Pokemon |
| `UseItemAction` | +5 | No | Use item from bag |
| `UseMoveAction` | Varies | Yes | Use a move |
| `FleeAction` | +6 | No | Attempt to flee |
| `MegaEvolveAction` | +5.5 | No | Mega evolution |

### 9.2 Reaction Actions (Generated)

| Action | Description | Triggered By |
|--------|-------------|--------------|
| `DamageAction` | Apply HP damage | Moves, RecoilEffect, Status |
| `HealAction` | Restore HP | Moves, Items, Abilities |
| `FaintAction` | Pokemon faints | HP reaching 0 |
| `StatChangeAction` | Modify stat stage | Moves, Abilities |
| `ApplyStatusAction` | Apply persistent status | Moves |
| `CureStatusAction` | Remove status | Moves, Items |
| `ApplyVolatileAction` | Apply volatile status | Moves |
| `RemoveVolatileAction` | Remove volatile | Turn end, Moves |
| `ConsumeItemAction` | Use up held item | Focus Sash, Berries |
| `WeatherDamageAction` | Sandstorm/Hail damage | End of turn |
| `StatusDamageAction` | Burn/Poison damage | End of turn |
| `HazardDamageAction` | Entry hazard damage | Switch in |

### 9.3 Presentation Actions

| Action | Description |
|--------|-------------|
| `MessageAction` | Display text in battle log |
| `AnimationAction` | Play move/effect animation |
| `SoundAction` | Play sound effect |
| `HPBarUpdateAction` | Animate HP bar change |
| `StatChangeVisualAction` | Show stat change indicator |

---

## 10. Implementation Phases

### Phase 1: Core Actions (Current)
- [x] `BattleAction` base class
- [x] `MessageAction`
- [x] `BattleQueue` processing
- [ ] `DamageAction` with faint check
- [ ] `HealAction`
- [ ] `FaintAction`

### Phase 2: Status System
- [ ] `ApplyStatusAction`
- [ ] `CureStatusAction`
- [ ] Status listeners (Burn, Paralysis, Sleep, etc.)
- [ ] Volatile status listeners (Confusion, Flinch)

### Phase 3: Stat System
- [ ] `StatChangeAction`
- [ ] OnStatChangeAttempt interception
- [ ] OnStatChanged reactions

### Phase 4: Move Execution
- [ ] `UseMoveAction` full flow
- [ ] Accuracy checks
- [ ] Type effectiveness integration
- [ ] Multi-hit moves

### Phase 5: Abilities & Items
- [ ] `IBattleListener` integration
- [ ] Common abilities (Intimidate, Static, Levitate)
- [ ] Common items (Leftovers, Choice Band, Focus Sash)

### Phase 6: Field Effects
- [ ] Weather actions and damage
- [ ] Hazard actions
- [ ] Screen actions

---

## 11. Testing Strategy

### Unit Tests (Per Action)
```csharp
[Test]
public void DamageAction_ReducesHP()
{
    var slot = CreateSlotWithPokemon(hp: 100);
    var action = new DamageAction(slot, 30);
    
    action.ExecuteLogic(field);
    
    Assert.That(slot.Pokemon.CurrentHP, Is.EqualTo(70));
}

[Test]
public void DamageAction_WhenKO_ReturnsFaintAction()
{
    var slot = CreateSlotWithPokemon(hp: 20);
    var action = new DamageAction(slot, 30);
    
    var reactions = action.ExecuteLogic(field);
    
    Assert.That(reactions, Has.Exactly(1).TypeOf<FaintAction>());
}
```

### Integration Tests (Trigger Flow)
```csharp
[Test]
public async Task FocusSash_PreventsOHKO_WhenFullHP()
{
    var slot = CreateSlotWithPokemon(hp: 100, maxHp: 100);
    slot.Pokemon.HeldItem = new FocusSashItem();
    
    var action = new DamageAction(slot, 150);
    await queue.ProcessAction(action, field, view);
    
    Assert.That(slot.Pokemon.CurrentHP, Is.EqualTo(1));
    Assert.That(slot.Pokemon.HeldItem, Is.Null); // Consumed
}
```

### Scenario Tests (Full Battle)
```csharp
[Test]
public async Task Intimidate_LowersAttack_OnSwitchIn()
{
    // Setup: Pikachu vs Gyarados
    var pikachu = CreateSlot(PokemonCatalog.Pikachu, level: 50);
    var gyarados = CreateSlot(PokemonCatalog.Gyarados, level: 50);
    gyarados.Pokemon.Ability = new IntimidateAbility();
    
    // Gyarados switches in
    await engine.ProcessSwitchIn(gyarados);
    
    // Pikachu's Attack should be lowered
    Assert.That(pikachu.GetStatStage(Stat.Attack), Is.EqualTo(-1));
}
```

