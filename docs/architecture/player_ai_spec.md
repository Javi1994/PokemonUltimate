# Input & AI Specification

## 1. Overview
To support **Manual Play**, **AI Enemies**, and **Autoplay** (AI playing for the user), we abstract the source of decisions. The Combat Engine does not care *who* makes the decision, only that an Action is provided.

## 2. Core Abstraction: `IActionProvider`

Every active Pokemon in battle is assigned a "Brain" (Provider).

```csharp
public interface IActionProvider {
    // Returns the Action the pokemon wants to perform this turn.
    // Async because Player input takes time (UI), while AI is instant.
    Task<BattleAction> GetAction(BattleField field, BattleSlot mySlot);
}
```

## 3. Implementations

### A. `PlayerInputProvider` (Manual Control)
Connects the Logic to the View/UI.

```csharp
public class PlayerInputProvider : IActionProvider {
    private IBattleView _view;

    public async Task<BattleAction> GetAction(BattleField field, BattleSlot mySlot) {
        // 1. Select Move
        var move = await _view.SelectMove(mySlot.Pokemon.Moves);

        // 2. Get Valid Targets (using the Resolver)
        var validTargets = TargetResolver.GetValidTargets(mySlot, move.Data, field);

        // 3. Select Target
        BattleSlot target = null;
        if (validTargets.Count == 1) {
            target = validTargets[0]; // Auto-select
        } else {
            target = await _view.SelectTarget(validTargets);
        }
        
        return new UseMoveAction(mySlot, move.Data, target);
    }
}
```

### B. `AIActionProvider` (The Bot)
Pure logic decision maker.

```csharp
public class AIActionProvider : IActionProvider {
    private IAILogic _logic; // Strategy (Random, Aggressive, Smart)

    public async Task<BattleAction> GetAction(BattleField field, BattleSlot mySlot) {
        // Optional: Fake thinking delay for realism
        await Task.Delay(500); 
        
        // Delegate decision to the strategy
        return _logic.DecideBestAction(field, mySlot);
    }
}
```

## 4. The "Autoplay" Feature
Implementing Autoplay is trivial with this pattern. We simply swap the provider at runtime.

```csharp
public class BattleManager {
    public void ToggleAutoplay(bool enabled) {
        foreach (var slot in PlayerSide.ActiveSlots) {
            if (enabled) {
                // Replace Player Input with AI
                slot.ActionProvider = new AIActionProvider(new SmartAIStrategy());
            } else {
                // Restore Manual Control
                slot.ActionProvider = new PlayerInputProvider(_view);
            }
        }
    }
}
```

## 5. AI Logic Strategies (`IAILogic`)
We can have different "brains" for different difficulty levels.

### `RandomAI`
-   Picks a random valid move.

### `SmartAI` (Standard Enemy / Autoplay)
1.  **Kill Check**: Does any move kill the target? -> Use it.
2.  **Type Matchup**: Filter moves that are Super Effective.
3.  **Status Check**: If target is not burned/poisoned, prioritize Status moves.
4.  **Healing**: If HP < 30%, use Potion or Heal move.

```csharp
public BattleAction DecideBestAction(BattleField field, BattleSlot me) {
    // We evaluate every possible Move + Target combination
    var bestOption = new { Score = -999f, Action = (BattleAction)null };

    foreach (var move in me.Pokemon.Moves) {
        var targets = TargetResolver.GetValidTargets(me, move.Data, field);
        
        foreach (var target in targets) {
            float score = Evaluate(move, target);
            if (score > bestOption.Score) {
                bestOption = new { Score = score, Action = new UseMoveAction(me, move.Data, target) };
            }
        }
    }
        
    return bestOption.Action ?? new WaitAction(me);
}
```

## 6. Integration with Action Queue
The flow remains perfectly consistent with our "Everything is an Action" rule.

1.  **PhaseActionSelection**:
    ```csharp
    foreach (var slot in AllActiveSlots) {
        // Engine doesn't know if this is Player or AI
        var action = await slot.ActionProvider.GetAction(field, slot);
        _queue.Enqueue(action);
    }
    ```
2.  **PhaseExecution**:
    The Queue processes the actions. The `UseMoveAction` generated by the AI is identical to the one generated by the Player.

## 7. Testability
-   **Test AI**: Create a `BattleField`, run `SmartAI.DecideBestAction`, assert it chose "Water Gun" against "Geodude".
-   **Test Player Flow**: Mock `IBattleView` to return a specific input immediately, assert `PlayerInputProvider` returns the correct Action.
